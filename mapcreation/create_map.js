fs = require('fs');
const sqlite3 = require('sqlite3').verbose();


let db = null;

let index;
let cells = [];
let stringToWrite;

main();

async function main() {
    db = await new sqlite3.Database('./dataEtheria.db', sqlite3.OPEN_READONLY, async (err) => {
    if (err) {
        console.error(err.message);
    }
    await console.log('Connected to the Etheria database.');
});
    for (index = 0; index <= 1088; index++) {
        let [col, row] = [Math.floor(index / 33),index % 33];
        await evenr_to_cube(col,row);
    }
    let stringifycells = JSON.stringify(cells);
    stringToWrite = {
        "size": 5,
        "cellSize": 10,
        "extrudeSettings": {
            "amount": 1,
            "bevelEnabled": true,
            "bevelSegments": 1,
            "steps": 1,
            "bevelSize": 0.5,
            "bevelThickness": 0.5,
            "arrays": {
                "position": [],
                "uv": [],
                "index": []
            }
        },
        "autogenerated": true,
        "cells": cells
    };
    console.log(JSON.stringify(stringToWrite));

    // Write to File
        fs.writeFile('../hex-map.json', JSON.stringify(stringToWrite), function (err) {
            if (err) return console.log(err);
            console.log('Cells > ${txtFile}');
        });
}

async function evenr_to_cube(col,row){
    var x = (col - (row - (row&1)) / 2)-8;
    var z = row-10;
    var y = -x-z+10;
    var colrow = {"col": col, "row": row};
    console.log(await getElevation(1.1,col,row));
    cells.push({
        "q":x,
        "r":y,
        "s":z,
        "h": (await getElevation(1.1,col,row))/10,
        "walkable": true,
        "userData": colrow
    });
  }
 async function getElevation(version,col,row) {
    let elev;
        await db.all(`SELECT elevation
                FROM tile
                WHERE version = ?
                  AND col_tile = ? AND row_tile = ?`, [version, col, row], async (err, rows) => {
            if (err) {
                throw err;
            }
            await rows.forEach((row) => {
                elev = row.elevation;
                return elev;
            });
        });
  }
